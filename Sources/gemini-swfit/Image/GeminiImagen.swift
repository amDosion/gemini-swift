import Foundation
import SwiftyBeaver

// MARK: - Imagen 4 Configuration

/// Configuration for Imagen 4 image generation
public struct ImagenConfig: Sendable {
    /// Number of images to generate (1-4)
    public let sampleCount: Int

    /// Aspect ratio
    public let aspectRatio: ImagenAspectRatio

    /// Safety filter level
    public let safetyFilterLevel: ImagenSafetyFilter

    /// Person generation setting
    public let personGeneration: ImagenPersonGeneration

    /// Output options
    public let outputOptions: ImagenOutputOptions

    /// Whether to include RAI filter reasons
    public let includeRaiReason: Bool

    public init(
        sampleCount: Int = 1,
        aspectRatio: ImagenAspectRatio = .square1x1,
        safetyFilterLevel: ImagenSafetyFilter = .blockMediumAndAbove,
        personGeneration: ImagenPersonGeneration = .dontAllow,
        outputOptions: ImagenOutputOptions = .default,
        includeRaiReason: Bool = false
    ) {
        self.sampleCount = min(4, max(1, sampleCount))
        self.aspectRatio = aspectRatio
        self.safetyFilterLevel = safetyFilterLevel
        self.personGeneration = personGeneration
        self.outputOptions = outputOptions
        self.includeRaiReason = includeRaiReason
    }

    public static let `default` = ImagenConfig()

    public static let highQuality = ImagenConfig(
        aspectRatio: .square1x1,
        outputOptions: ImagenOutputOptions(compressionQuality: 100)
    )
}

/// Imagen aspect ratios
public enum ImagenAspectRatio: String, Codable, Sendable {
    case square1x1 = "1:1"
    case portrait3x4 = "3:4"
    case landscape4x3 = "4:3"
    case portrait9x16 = "9:16"
    case landscape16x9 = "16:9"
}

/// Imagen safety filter
public enum ImagenSafetyFilter: String, Codable, Sendable {
    case blockLowAndAbove = "block_low_and_above"
    case blockMediumAndAbove = "block_medium_and_above"
    case blockOnlyHigh = "block_only_high"
    case blockNone = "block_none"
}

/// Imagen person generation
public enum ImagenPersonGeneration: String, Codable, Sendable {
    case dontAllow = "dont_allow"
    case allowAdult = "allow_adult"
    case allowAll = "allow_all"
}

/// Imagen output options
public struct ImagenOutputOptions: Sendable {
    public let mimeType: String
    public let compressionQuality: Int

    public init(mimeType: String = "image/png", compressionQuality: Int = 80) {
        self.mimeType = mimeType
        self.compressionQuality = min(100, max(1, compressionQuality))
    }

    public static let `default` = ImagenOutputOptions()
    public static let highQualityPNG = ImagenOutputOptions(mimeType: "image/png", compressionQuality: 100)
    public static let compressedJPEG = ImagenOutputOptions(mimeType: "image/jpeg", compressionQuality: 85)
}

// MARK: - Imagen Response

/// Response from Imagen generation
public struct ImagenResponse: Sendable {
    public let images: [ImagenGeneratedImage]
    public let raiFilteredReasons: [String]?

    public init(images: [ImagenGeneratedImage], raiFilteredReasons: [String]? = nil) {
        self.images = images
        self.raiFilteredReasons = raiFilteredReasons
    }
}

/// A single image generated by Imagen
public struct ImagenGeneratedImage: Sendable {
    public let data: Data
    public let mimeType: String
    public let gcsUri: String?

    public init(data: Data, mimeType: String, gcsUri: String? = nil) {
        self.data = data
        self.mimeType = mimeType
        self.gcsUri = gcsUri
    }

    public var base64String: String {
        return data.base64EncodedString()
    }

    public func save(to url: URL) throws {
        try data.write(to: url)
    }
}

// MARK: - Imagen Client

/// Client for Imagen 4 image generation
public actor ImagenClient {
    private let apiKey: String
    private let baseURL: String
    private let session: URLSession
    private let logger: SwiftyBeaver.Type

    public enum ImagenModel: String, Sendable {
        case imagen4Ultra = "imagen-4-ultra"
        case imagen4Standard = "imagen-4-standard"

        public var displayName: String {
            switch self {
            case .imagen4Ultra: return "Imagen 4 Ultra"
            case .imagen4Standard: return "Imagen 4 Standard"
            }
        }
    }

    public init(
        apiKey: String,
        baseURL: String = "https://generativelanguage.googleapis.com/v1beta",
        logger: SwiftyBeaver.Type = SwiftyBeaver.self
    ) {
        self.apiKey = apiKey
        self.baseURL = baseURL
        self.session = URLSession.shared
        self.logger = logger
    }

    /// Generate images using Imagen 4
    public func generate(
        prompt: String,
        model: ImagenModel = .imagen4Standard,
        config: ImagenConfig = .default
    ) async throws -> ImagenResponse {
        let url = URL(string: "\(baseURL)/models/\(model.rawValue):predict?key=\(apiKey)")!

        let requestBody: [String: Any] = [
            "instances": [
                ["prompt": prompt]
            ],
            "parameters": [
                "sampleCount": config.sampleCount,
                "aspectRatio": config.aspectRatio.rawValue,
                "safetyFilterLevel": config.safetyFilterLevel.rawValue,
                "personGeneration": config.personGeneration.rawValue,
                "outputOptions": [
                    "mimeType": config.outputOptions.mimeType,
                    "compressionQuality": config.outputOptions.compressionQuality
                ],
                "includeRaiReason": config.includeRaiReason
            ]
        ]

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        logger.info("Generating image with Imagen: \(model.rawValue)")

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw ImagenError.invalidResponse
        }

        guard httpResponse.statusCode == 200 else {
            let errorMessage = String(data: data, encoding: .utf8) ?? "Unknown error"
            logger.error("Imagen generation failed: \(errorMessage)")
            throw ImagenError.generationFailed(errorMessage)
        }

        return try parseResponse(data)
    }

    /// Generate with negative prompt
    public func generate(
        prompt: String,
        negativePrompt: String,
        model: ImagenModel = .imagen4Standard,
        config: ImagenConfig = .default
    ) async throws -> ImagenResponse {
        let url = URL(string: "\(baseURL)/models/\(model.rawValue):predict?key=\(apiKey)")!

        let requestBody: [String: Any] = [
            "instances": [
                [
                    "prompt": prompt,
                    "negativePrompt": negativePrompt
                ]
            ],
            "parameters": [
                "sampleCount": config.sampleCount,
                "aspectRatio": config.aspectRatio.rawValue,
                "safetyFilterLevel": config.safetyFilterLevel.rawValue,
                "personGeneration": config.personGeneration.rawValue,
                "outputOptions": [
                    "mimeType": config.outputOptions.mimeType,
                    "compressionQuality": config.outputOptions.compressionQuality
                ]
            ]
        ]

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            let errorMessage = String(data: data, encoding: .utf8) ?? "Unknown error"
            throw ImagenError.generationFailed(errorMessage)
        }

        return try parseResponse(data)
    }

    /// Edit an image using Imagen
    public func edit(
        image: ImageInput,
        prompt: String,
        mask: ImageInput? = nil,
        model: ImagenModel = .imagen4Standard,
        config: ImagenConfig = .default
    ) async throws -> ImagenResponse {
        let url = URL(string: "\(baseURL)/models/\(model.rawValue):predict?key=\(apiKey)")!

        var instance: [String: Any] = [
            "prompt": prompt
        ]

        // Add source image
        if let imageData = image.data {
            instance["image"] = [
                "bytesBase64Encoded": imageData.base64EncodedString()
            ]
        }

        // Add mask if provided
        if let maskInput = mask, let maskData = maskInput.data {
            instance["mask"] = [
                "image": [
                    "bytesBase64Encoded": maskData.base64EncodedString()
                ]
            ]
        }

        let requestBody: [String: Any] = [
            "instances": [instance],
            "parameters": [
                "sampleCount": config.sampleCount,
                "safetyFilterLevel": config.safetyFilterLevel.rawValue,
                "outputOptions": [
                    "mimeType": config.outputOptions.mimeType,
                    "compressionQuality": config.outputOptions.compressionQuality
                ]
            ]
        ]

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            let errorMessage = String(data: data, encoding: .utf8) ?? "Unknown error"
            throw ImagenError.generationFailed(errorMessage)
        }

        return try parseResponse(data)
    }

    /// Upscale an image
    public func upscale(
        image: ImageInput,
        upscaleFactor: UpscaleFactor = .x2
    ) async throws -> ImagenResponse {
        let url = URL(string: "\(baseURL)/models/imagen-4-standard:predict?key=\(apiKey)")!

        guard let imageData = image.data else {
            throw ImagenError.invalidImage
        }

        let requestBody: [String: Any] = [
            "instances": [
                [
                    "image": [
                        "bytesBase64Encoded": imageData.base64EncodedString()
                    ]
                ]
            ],
            "parameters": [
                "mode": "upscale",
                "upscaleFactor": upscaleFactor.rawValue
            ]
        ]

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            let errorMessage = String(data: data, encoding: .utf8) ?? "Unknown error"
            throw ImagenError.generationFailed(errorMessage)
        }

        return try parseResponse(data)
    }

    // MARK: - Private

    private func parseResponse(_ data: Data) throws -> ImagenResponse {
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let predictions = json["predictions"] as? [[String: Any]] else {
            throw ImagenError.invalidResponse
        }

        var images: [ImagenGeneratedImage] = []
        var raiReasons: [String]?

        for prediction in predictions {
            if let bytesBase64 = prediction["bytesBase64Encoded"] as? String,
               let imageData = Data(base64Encoded: bytesBase64) {
                let mimeType = prediction["mimeType"] as? String ?? "image/png"
                let gcsUri = prediction["gcsUri"] as? String

                images.append(ImagenGeneratedImage(
                    data: imageData,
                    mimeType: mimeType,
                    gcsUri: gcsUri
                ))
            }

            if let raiReason = prediction["raiFilteredReason"] as? String {
                if raiReasons == nil { raiReasons = [] }
                raiReasons?.append(raiReason)
            }
        }

        return ImagenResponse(images: images, raiFilteredReasons: raiReasons)
    }
}

/// Upscale factor
public enum UpscaleFactor: String, Sendable {
    case x2 = "x2"
    case x4 = "x4"
}

// MARK: - Imagen Errors

public enum ImagenError: Error, LocalizedError {
    case invalidResponse
    case generationFailed(String)
    case invalidImage
    case quotaExceeded
    case contentFiltered(String)

    public var errorDescription: String? {
        switch self {
        case .invalidResponse:
            return "Invalid response from Imagen API"
        case .generationFailed(let message):
            return "Image generation failed: \(message)"
        case .invalidImage:
            return "Invalid input image"
        case .quotaExceeded:
            return "Imagen API quota exceeded"
        case .contentFiltered(let reason):
            return "Content was filtered: \(reason)"
        }
    }
}
